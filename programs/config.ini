#
# Memory request time = MemoryBaseRequestTime + MemoryTimePerLine * ceil(RequestSize / MemorySizeOfLine)
#
MemoryBaseRequestTime  = 0
MemoryTimePerLine      = 1
MemorySizeOfLine       = 8
MemoryBufferSize       = -1
MemoryType             = RandomBanked
# MemoryBanks            = 4    # When left out, will default to the total of NumProcessors

NumProcessors = 128
NumProcessorsPerFPU = 2
CoreFreq = 1000 # MHz
MemoryFreq = 1000 # MHz

# the control block size and cache line size are pervasive, we don't support fine-grained
# configuration of this yet.
ControlBlockSize = 64	        # Must be 64 or less, and a power of two
CacheLineSize    = 64		# Must be at least ControlBlockSize, and a power of two


#
# Instruction Cache
# Total Size = ICacheNumSets * ICacheAssociativity * CacheLineSize
#
*.ICache.Associativity = 4
*.ICache.NumSets       = 4
*.ICache.OutgoingBufferSize = 1
*.ICache.IncomingBufferSize = 1

#
# Data Cache
# Total Size = DCacheNumSets * DCacheAssociativity * CacheLineSize
#
*.DCache.Associativity = 4
*.DCache.NumSets       = 4
*.DCache.CompletedWriteBufferSize = 1
*.DCache.OutgoingBufferSize = 1

#
# Thread and Family Table
#
# FIXME: this ought to be configurable per core, however for now the
# network code does not properly adjust the TID and FID widths.  so we
# use a single configuration for now.
*.Threads.NumEntries = 256
*.Families.NumEntries = 32

#
# Register file
#
NumIntRegisters       = 1024
IntRegistersBlockSize = 32
NumFltRegisters       = 1024
FltRegistersBlockSize = 32

#
# Pipeline
#
NumPipelineDummyStages = 0  # Number of delay stages between Memory and Writeback

#
# Ancillary registers
#
*.NumAncillaryRegisters = 1

#
# Misc. Buffer and queue sizes (-1 is infinite)
#

*.Alloc.InitialThreadAllocateQueueSize = 32 # needs not be larger than Families.NumEntries, because there cannot be more families waiting for initial thread allocation.
*.Alloc.CreateQueueSize  = 32 # idem InitialThreadAllocateQueueSize
*.Alloc.ThreadCleanupQueueSize = 256 # needs not be larger than Threads.NumEntries, because there cannot be more threads waiting for final thread cleanup.

# FIXME: The following allocate queues should not be unbounded, but
# they have to be until the network implements separate channels for
# suspending and non-suspending operations.
*.Alloc.FamilyAllocationSuspendQueueSize = -1
*.Alloc.FamilyAllocationNoSuspendQueueSize = -1
*.Alloc.FamilyAllocationExclusiveQueueSize = -1


#
# FPU configuration
#
*FPU*.NumUnits        = 5         # Number of FPU pipelines
*FPU*.Source*.InputQueueSize = 1  # queue size from each processor

*FPU*.Unit0Ops       = Add,Sub
*FPU*.Unit0Latency   = 3
*FPU*.Unit0Pipelined = true

*FPU*.Unit1Ops       = Add,Sub
*FPU*.Unit1Latency   = 3
*FPU*.Unit1Pipelined = true

*FPU*.Unit2Ops       = Mul
*FPU*.Unit2Latency   = 3
*FPU*.Unit2Pipelined = true

*FPU*.Unit3Ops       = Div
*FPU*.Unit3Latency   = 8
*FPU*.Unit3Pipelined = false

*FPU*.Unit4Ops       = Sqrt
*FPU*.Unit4Latency   = 10
*FPU*.Unit4Pipelined = false

#
# COMA memory settings
#

# DDR Timings, defaults appropriate for DDR3-1600
# Configuration based on the Micron MT41J128M8.
DDRMemoryFreq = 800 # MHz
DDR_tCL  = 11   # CAS Latency (in mem clock cycles = tCK)
DDR_tRCD = 11   # RAS to CAS Delay (in mem clock cycles = tCK)
DDR_tRP  = 11   # RAS Precharge Delay (in mem clock cycles = tCK)
DDR_tRAS = 28   # RAS Active Delay (in mem clock cycles = tCK)

DDR_tAL  = 0    # Additive Latency (in mem clock cycles = tCK)
DDR_tCWL = 8    # CAS Write Latency (in mem clock cycles = tCK)
DDR_tCCD = 4    # CAS to CAS delay (in mem clock cycles = tCK)

DDR_tWR = 15    # Write recovery time in nanoseconds
                # see http://www.samsung.com/global/business/semiconductor/products/dram/downloads/applicationnote/tWR.pdf

# DDR Timings for DDR3-2400
# Configuration based on Kingston HyperX technology
# see http://www.legitreviews.com/article/1274/4/
#DDR_tCL  = 9
#DDR_tRCD = 11
#DDR_tRP  = 9
#DDR_tRAS = 27
#DDR_tCWL = 10   # CWL goes up as the frequency goes up
#DDR_tCCD = 4    # CCD minimum according to JEDEC
#DDRMemoryFreq = 1200 # MHz

# DDR data layout
# defaults suitable for 4GB DIMM with ECC.
DDR_Banks          = 8
DDR_DevicesPerRank = 8
DDR_Ranks          = 2
DDR_RowBits        = 15
DDR_ColumnBits     = 10

# DDR3 constants:
DDR_DataPath       = 64
DDR_CellSize       = 8 # DDR: 1 byte.
DDR_BurstLength    = 8 # DDR3: data rate (2) times multiplier (4)

COMA_NodeBufferSize = 2 # Size of incoming and outgoing buffer on the ring nodes

NumProcessorsPerCache = 4
NumCachesPerDirectory = 8
NumRootDirectories    = 1
# NumMemoryChannels     = 1 # When left out, defaults to NumRootDirectories

EnableCacheInjection = true
L2CacheDelay = 2
L2CacheAssociativity = 4
L2CacheNumSets = 128


RootDirectoryExternalOutputQueueSize = -1
RootDirectoryExternalInputQueueSize = -1

#
# Monitor settings
#
MonitorSampleDelay = 0.001 # delay in seconds
MonitorSampleVariables = *cpu*.pipeline.execute.op, *cpu*.pipeline.execute.flop
MonitorMetadataFile = mgtrace.md
MonitorTraceFile = mgtrace.out

#
# Core I/O settings
#
PerformanceCountersBaseAddr = 8
DebugChannelStdoutBaseAddr = 0x200
DebugChannelStderrBaseAddr = 0x230

#
# I/O settings
#
IOFreq = 1000         # MHz
NumIOBuses = 1
IOBUS0Type = NULLIO

CPU0EnableIO = true
CPU0BusID = 0
CPU0DeviceID = 0
CPU0AsyncIOBaseAddr = 0x40000000     # base address for load/stores to I/O devices
CPU0PICBaseAddr = 0x3fffff00         # base address for notification waits

*.IO_IF.AIO.DeviceAddressBits = 24   # address space size per device
*.IO_IF.NumDeviceSlots = 16          # number of devices supported (number of address spaces from AsyncIOBaseAddr)
*.IO_IF.NumInterruptChannels = 8     # number of notification channels (number of words from PICBaseAddr)
*.IO_IF.BUS_IF.OutgoingRequestQueueSize = 3 # should be at least 3 to accommodate for pipeline loopback
*.IO_IF.RRMUX.WritebackQueueSize = 3        # idem
*.IO_IF.RRMUX.IncomingQueueSize = 1         # response queue from bus

# Example to connect CPU1 to the same bus:
# CPU1EnableIO = true
# CPU1BusID = 0 # same bus as above
# CPU1DeviceID = 1 # however different device ID

NumIODevices = 4

IODEV0BusID = 0
IODEV0DeviceID = 1
IODEV0Type = LCD
IODEV0Config = Console

IODEV1BusID = 0
IODEV1DeviceID = 2
IODEV1Type = LCD
IODEV1Config = LCD

IODEV2BusID = 0
IODEV2DeviceID = 3
IODEV2Type = RTC

IODEV3BusID = 0
IODEV3DeviceID = 4
IODEV3Type = GFX

LCDDisplayWidth = 16
LCDDisplayHeight = 2
LCDOutputRow = 10
LCDOutputColumn = 32
LCDBackgroundColor = 2
LCDForegroundColor = 0

ConsoleDisplayWidth = 80
ConsoleDisplayHeight = 25
ConsoleOutputRow = 1
ConsoleOutputColumn = 1
ConsoleBackgroundColor = 0
ConsoleForegroundColor = 7

RTCUpdateFreq = 1 # megahertz of simulated time

#
# Graphical output
#
*IODEV3*FrameBufferSize = 5242880 # 1280x1024x32bpp
*IODEV3*EnableSDLOutput = true

# the following parameters are not name-qualified, they
# apply either to singleton components or component-less
# properties.

# this applies to the update timer shared by all RTC clocks.
RTCMeatSpaceUpdateInterval = 100000 # microseconds of real time

# these apply to the unique SDL graphical output
SDLHorizScale      = 2
SDLVertScale       = 2
SDLRefreshDelay    = 1000000 # number of master cycles between updates

