NumProcessors = 128
NumProcessorsPerFPU = 2

MemoryType = RandomBanked

#
# Monitor settings
#
MonitorSampleDelay = 0.001 # delay in seconds
MonitorSampleVariables = *cpu*.pipeline.execute.op, *cpu*.pipeline.execute.flop
MonitorMetadataFile = mgtrace.md
MonitorTraceFile = mgtrace.out


#######################################################################################
###### Per-processor configuration
#######################################################################################

# Shared by all processors - for now
CoreFreq = 1000    # MHz

# The control block is the sequence of instructions controlled by one
# control word. The control word contains exactly 2 bits per
# instruction in the control block.  On our targets, instructions are
# 32-bit wide.  A control word has also at most the size of an instruction.
# So the control word defines a control block of at most 32/2 = 16 instructions.
# This is 64 bytes (4 bytes per instruction). A smaller control block
# is possible, for example to allow for a smaller cache line size.
ControlBlockSize = 64

#
# Core/memory interface constants
#
# the cache line size is pervasive, we don't support fine-grained
# configuration of this yet.
CacheLineSize    = 64	# Must be at least ControlBlockSize, and a power of two

#
# L1 Cache configuration
#

#
# Instruction Cache
# Total Size = ICacheNumSets * ICacheAssociativity * CacheLineSize
#
*.CPU*.ICache.Associativity = 4
*.CPU*.ICache.NumSets       = 4
*.CPU*.ICache.OutgoingBufferSize = 1
*.CPU*.ICache.IncomingBufferSize = 1

#
# Data Cache
# Total Size = DCacheNumSets * DCacheAssociativity * CacheLineSize
#
*.CPU*.DCache.Associativity = 4
*.CPU*.DCache.NumSets       = 4
*.CPU*.DCache.CompletedWriteBufferSize = 1
*.CPU*.DCache.OutgoingBufferSize = 1

#
# Thread and Family Table
#
# FIXME: this ought to be configurable per core, however for now the
# network code does not properly adjust the TID and FID widths.  so we
# use a single shared configuration for the time being.
*.CPU*.Threads.NumEntries = 256
*.CPU*.Families.NumEntries = 32

#
# Register file
#
# FIXME: this ought to be configurable per core, however for now
# the network code does not properly adjust the RID width. so
# we use a single shared configuration for the time being.
*.CPU*.Registers.NumIntRegisters       = 1024
*.CPU*.Registers.NumFltRegisters       = 1024

#
# Register allocation unit
#
*.CPU*.RAU.IntRegistersBlockSize = 32
*.CPU*.RAU.FltRegistersBlockSize = 32

#
# Pipeline
#
*.CPU*.Pipeline.NumDummyStages = 0  # Number of delay stages between Memory and Writeback

#
# Ancillary registers
#
*.CPU*.NumAncillaryRegisters = 1

#
# Thread/family allocator
#

*.CPU*.Alloc.InitialThreadAllocateQueueSize = 32 # needs not be larger than Families.NumEntries, because there cannot be more families waiting for initial thread allocation.
*.CPU*.Alloc.CreateQueueSize  = 32 # idem InitialThreadAllocateQueueSize
*.CPU*.Alloc.ThreadCleanupQueueSize = 256 # needs not be larger than Threads.NumEntries, because there cannot be more threads waiting for final thread cleanup.

# FIXME: The following allocate queues should not be unbounded, but
# they have to be until the network implements separate channels for
# suspending and non-suspending operations.
*.CPU*.Alloc.FamilyAllocationSuspendQueueSize = -1
*.CPU*.Alloc.FamilyAllocationNoSuspendQueueSize = -1
*.CPU*.Alloc.FamilyAllocationExclusiveQueueSize = -1

#
# Settings for on-die misc. I/O components
#
*.CPU*.PerfCounters.MMIO_BaseAddr = 8
*.CPU*.Debug_Stdout.MMIO_BaseAddr = 0x200
*.CPU*.Debug_Stderr.MMIO_BaseAddr = 0x230



#######################################################################################
###### Per-FPU configuration
#######################################################################################

*.FPU*.NumUnits        = 5         # Number of FPU pipelines
*.FPU*.Source*.InputQueueSize = 1  # queue size from each processor

*.FPU*.Unit0Ops       = Add,Sub
*.FPU*.Unit0Latency   = 3
*.FPU*.Unit0Pipelined = true

*.FPU*.Unit1Ops       = Add,Sub
*.FPU*.Unit1Latency   = 3
*.FPU*.Unit1Pipelined = true

*.FPU*.Unit2Ops       = Mul
*.FPU*.Unit2Latency   = 3
*.FPU*.Unit2Pipelined = true

*.FPU*.Unit3Ops       = Div
*.FPU*.Unit3Latency   = 8
*.FPU*.Unit3Pipelined = false

*.FPU*.Unit4Ops       = Sqrt
*.FPU*.Unit4Latency   = 10
*.FPU*.Unit4Pipelined = false



#######################################################################################
###### Memory network configuration
#######################################################################################

# Frequency of memory network
MemoryFreq = 1000  # MHz

# Serial, Parallel, Banked and RandomBanked memory
# 
# *.Memory.NumClients  = 128  # When left out, defaults to NumProcessors (to which it must be equal)
*.Memory.BaseRequestTime  = 1
*.Memory.TimePerLine      = 1
*.Memory.LineSize         = 8
*.Memory.BufferSize       = -1

# Banked and RandomBanked memory
# 
# *.Memory.NumBanks    = 4    # When left out, will default to NumProcessors

#
# COMA memory settings
#
NumProcessorsPerL2Cache = 4

*.Memory.NumL2CachesPerDirectory = 8
*.Memory.NumRootDirectories      = 1

*.Memory.EnableCacheInjection = true # For ZLCOMA only

*.Memory.*.NodeBufferSize = 2 # Size of incoming and outgoing buffer on the ring nodes

# L2 cache parameters
*.Memory.L2CacheAssociativity = 4
*.Memory.L2CacheNumSets = 128
*.Memory.Cache*.RequestBufferSize = 1   # size of buffer for requests from L1 to L2
*.Memory.Cache*.ResponseBufferSize = 1  # size of buffer for responses from L2 to L1

# *.Memory.RootDir*.DDRChannelID = 0 # When left out, defaults to the Root Directory ID
*.Memory.RootDir*.ExternalOutputQueueSize = -1
*.Memory.RootDir*.ExternalInputQueueSize = -1


###### DDR Channel configuration

# *.DDR.NumChannels     = 1 # When left out, defaults to Memory.NumRootDirectories

# DDR3 constants:
*.DDR.Channel*.CellSize       = 8 # DDR: 1 byte.
*.DDR.Channel*.BurstLength    = 8 # DDR3: data rate (2) times multiplier (4)

# Latencies in DDR specs are expressed in tCK (mem cycles).

# DDR chip timings, defaults appropriate for DDR3-1600
# Configuration based on the Micron MT41J128M8.

*.DDR.Channel*.Freq = 800 # MHz
*.DDR.Channel*.Config.tCL  = 11   # CAS Latency (in mem clock cycles = tCK)
*.DDR.Channel*.Config.tRCD = 11   # RAS to CAS Delay (in mem clock cycles = tCK)
*.DDR.Channel*.Config.tRP  = 11   # RAS Precharge Delay (in mem clock cycles = tCK)
*.DDR.Channel*.Config.tRAS = 28   # RAS Active Delay (in mem clock cycles = tCK)
*.DDR.Channel*.Config.tCWL = 8    # CAS Write Latency (in mem clock cycles = tCK)
*.DDR.Channel*.Config.tCCD = 4    # CAS to CAS delay (in mem clock cycles = tCK)
*.DDR.Channel*.Config.tWR = 15    # Write recovery time in nanoseconds
# tWR: see http://www.samsung.com/global/business/semiconductor/products/dram/downloads/applicationnote/tWR.pdf

# *.DDR.Channel*.Config.tAL  = 0    # Additive Latency (in mem clock cycles = tCK) - NOT USED


# DDR chip timings for DDR3-2400
# Configuration based on Kingston HyperX technology
# see http://www.legitreviews.com/article/1274/4/
#
#*.DDR.Channel*.Freq = 1200 # MHz
#*.DDR.Channel*.Config.tCL  = 9
#*.DDR.Channel*.Config.tRCD = 11
#*.DDR.Channel*.Config.tRP  = 9
#*.DDR.Channel*.Config.tRAS = 27
#*.DDR.Channel*.Config.tCWL = 10   # CWL goes up as the frequency goes up
#*.DDR.Channel*.Config.tCCD = 4    # CCD minimum according to JEDEC
#*.DDR.Channel*.Config.tWR = 15    # Write recovery time in nanoseconds
# tWR: see http://www.samsung.com/global/business/semiconductor/products/dram/downloads/applicationnote/tWR.pdf

# DDR data layout
# defaults suitable for 4GB DIMM with ECC.
*.DDR.Channel*.Config.DevicesPerRank = 8
*.DDR.Channel*.Config.Ranks          = 2
*.DDR.Channel*.Config.RowBits        = 15
*.DDR.Channel*.Config.ColumnBits     = 10

#######################################################################################
###### I/O bus configuration
#######################################################################################

NumIOBuses = 1

*.IOBUS0.Type = NULLIO
*.IOBUS0.Freq = 1000    # MHz

#######################################################################################
###### Configuration for the Core - I/O bus interface
#######################################################################################

*.CPU0.EnableIO = true
*.CPU0.BusID = 0           # connect to bus 0
*.CPU0.DeviceID = 0        # device ID of core on bus is also 0

*.IO_IF.AIO.MMIO_BaseAddr = 0x40000000     # base address for load/stores to I/O devices
*.IO_IF.PNC.MMIO_BaseAddr = 0x3fffff00     # base address for notification waits

*.IO_IF.AIO.DeviceAddressBits = 24   # address space size per device
*.IO_IF.NumDeviceSlots = 16          # number of devices supported (number of address spaces from AsyncIOBaseAddr)
*.IO_IF.NumNotificationChannels = 8     # number of notification channels (number of words from PNCBaseAddr)
*.IO_IF.BUS_IF.OutgoingRequestQueueSize = 3 # should be at least 3 to accommodate for pipeline loopback
*.IO_IF.RRMux.WritebackQueueSize = 3        # idem
*.IO_IF.RRMux.IncomingQueueSize = 1         # response queue from bus
*.IO_IF.NMux.NotificationQueueSize = 1      # notification queue from bus

# Example to connect CPU1 to the same bus:
# CPU1EnableIO = true
# CPU1BusID = 0 # same bus as above
# CPU1DeviceID = 1 # however different device ID


#######################################################################################
###### I/O device configuration
#######################################################################################


NumIODevices = 4

*.IODEV*.BusID = 0

# *.DeviceID is the ID of the device on its bus,
# whereas N in "IODevN" is the global device ID
# (as per NumIODevices)

*.IODEV0.DeviceID = 1
*.IODEV0.Type = LCD

*.IODEV1.DeviceID = 2
*.IODEV1.Type = LCD

*.IODEV2.DeviceID = 3
*.IODEV2.Type = RTC

*.IODEV3.DeviceID = 4
*.IODEV3.Type = GFX

#
# LCD settings
#

# specific settings for Console first:
*.IODEV0.LCDDisplayWidth = 80
*.IODEV0.LCDDisplayHeight = 25
*.IODEV0.LCDOutputRow = 1
*.IODEV0.LCDOutputColumn = 1
*.IODEV0.LCDBackgroundColor = 0
*.IODEV0.LCDForegroundColor = 7

# defaults for all LCDs:
*.LCDDisplayWidth = 16
*.LCDDisplayHeight = 2
*.LCDOutputRow = 10
*.LCDOutputColumn = 32
*.LCDBackgroundColor = 2
*.LCDForegroundColor = 0

#
# RTC settings
#
# There can be several RTCs in the system.

*.RTCUpdateFreq = 1 # megahertz of simulated time

# this applies to the update timer shared by all RTC clocks.
RTCMeatSpaceUpdateInterval = 100000 # microseconds of real time


#
# Graphical output
#
# There can be several Gfxs in the system,
# however only one can have GfxEnableSDLOutput = true.

# *.GfxFrameBufferDeviceID = N  # When omitted, defaults to DeviceID + 1
*.GfxFrameBufferSize = 5MiB  # good for max rez 1280x1024x32bpp
*.GfxEnableSDLOutput = true

# these apply to the unique SDL graphical output
SDLHorizScale      = 2
SDLVertScale       = 2
SDLRefreshDelay    = 1000000 # number of master cycles between updates

