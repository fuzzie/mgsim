\chapter{I/O}

The microgrid as described so far is a standalone processor architecture and execution model with volatile storage. To enable non-volatile storage and the ability to affect the environment outside the system, an I/O mechanism is required. This is implemented in the form of one or more I/O busses which are connected to one or more dedicated I/O cores, such that every I/O core controls one I/O bus. These I/O cores, while they support the general microgrid paradigm, are intended to be used for I/O communication only\footnote{As an optimization, these cores can have reduced functionality due to their dedicated nature; for instance: no FPU or a smaller thread table.}

\section{General Mechanism}
In general, I/O is based on two forms of communication: requests and responses on the I/O bus, must like memory requests and responses, and interrupts. The former is to query or command a device. Examples include instructing a disk drive to read a sector, instructing a network controller to send a packet over the network, or querying the keyboard for the latest pressed key. Although a difference can be made between querying and commanding a device, both are essentially similar from a technical perspective; the processor sends a request over the I/O bus to the device, which replies with a response. This response can be as small as a single register, or as a big as several kilobytes of data. In the latter case, the processor usually includes a memory address in the request and the device writes the data to memory at the specified address.

Opposed to the processor instructing a device, it's possible for an external event to trigger a chance in a device that the processor needs to be notified of. This is done via an interrupt, where the device signals to the processors that it's state has changed. The processor usually awaits interrupts and, when notified, queries the device to find out what has happened.

These two core mechanisms can be combined into a single mechanism, combined with the microgrid's register suspension. One or more I/O instructions are introduced, implemented only on I/O cores, that communicate with the I/O controller that is part of the I/O core. These instructions can send a read or write to the device, or set the I/O controller up to connect a certain interrupt to the thread. A write involves specifying the address on the I/O bus to write to and a datum to write. A read involves specifying the address on the I/O bus to read from and a register in the thread's local register context to receive the datum. This register is cleared by the instruction and filled when the write completes. These two instructions, in essence, mirror memory reads and writes. The final instruction sets up the I/O controller to deliver certain interrupts to the register specified in the instruction. This register, from the thread's local register context, is cleared by the instruction and written by the I/O controller when that interrupt has been signalled.

Device access to memory is implemented by the I/O controller. Writes to memory by devices on the I/O bus are received by the I/O controller, which forwards the data as writes onto a memory bus that is connected to the memory system. In the case of the COMA memory as described in section~\ref{sec:coma}, this would send the data to an L2 cache. Similarly, reads from memory would be handled by the I/O controller as well.

\section{HyperTransport}
The current method for implementing I/O in the Microgrid is to connect a HyperTransport 3.1\cite{hypertransport} bus to an I/O core. A HyperTransport bus is a single 32-bit daisy-chained bus of devices. The bus consists of two links between each device, one for sending data towards the host controller and one for sending data to the devices. The links operate at 3.2 GHz with DDR, and as such a maximum theoretical bandwidth on the bus of 51.2 GB/s (25.6 GB/s each direction). HyperTransport uses a packet-based protocol allowing for priority injection of small packets into a large stream of packets from downstream devices. This injection allows devices to remain responsive.